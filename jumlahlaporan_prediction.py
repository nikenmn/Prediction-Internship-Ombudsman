# -*- coding: utf-8 -*-
"""JumlahLaporan_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s_fN-ovDYt0O0RUOo_0tkFTVaD2dZhqP
"""

!pip install xgboost

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from xgboost import XGBRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, make_scorer
from sklearn.model_selection import TimeSeriesSplit, RandomizedSearchCV
from google.colab import drive

drive.mount('/content/drive')

# =========================
# LOAD DATA
# =========================
file_path = "/content/drive/MyDrive/Intern Ombudsman/Jumlah_Laporan_Masuk.xlsx"
df = pd.read_excel(file_path)

df["ds"] = pd.to_datetime(
    df["tahun"].astype(str) + "-" + df["bulan"].astype(str) + "-01"
)

df = df.sort_values("ds")
df = df.rename(columns={"jumlah_laporan": "y"})

# Use full history (helps ML learn better)
df = df[df["ds"] >= "2007-12-01"].copy()

# =========================
# FEATURE ENGINEERING
# =========================

for lag in [1,2,3,6,12]:
    df[f"lag_{lag}"] = df["y"].shift(lag)

df["roll_mean_3"] = df["y"].rolling(3).mean()
df["roll_mean_6"] = df["y"].rolling(6).mean()
df["roll_std_6"] = df["y"].rolling(6).std()

df["diff_1"] = df["y"] - df["lag_1"]

df["month"] = df["ds"].dt.month
df["month_sin"] = np.sin(2*np.pi*df["month"]/12)
df["month_cos"] = np.cos(2*np.pi*df["month"]/12)

df["time_index"] = np.arange(len(df))

df = df.dropna()

# =========================
# TRAIN TEST SPLIT
# =========================

train = df.iloc[:-12]
test = df.iloc[-12:]

features = [col for col in df.columns if col not in ["ds","y","month"]]

X_train = train[features]
y_train = train["y"]

X_test = test[features]
y_test = test["y"]

# =========================
# SMAPE FUNCTION
# =========================

def smape(y_true, y_pred):
    denom = (np.abs(y_true) + np.abs(y_pred))
    denom[denom == 0] = 1
    return 100 * np.mean(2 * np.abs(y_pred - y_true) / denom)

smape_scorer = make_scorer(smape, greater_is_better=False)

# =========================
# RANDOM SEARCH (FAST)
# =========================

param_dist = {
    "n_estimators": [300, 500, 700],
    "learning_rate": [0.01, 0.03, 0.05],
    "max_depth": [3,4,5],
    "subsample": [0.7,0.8,0.9],
    "colsample_bytree": [0.7,0.8,0.9],
    "reg_alpha": [0, 0.1],
    "reg_lambda": [1, 1.5]
}

model = XGBRegressor(
    random_state=42,
    objective="reg:squarederror"
)

tscv = TimeSeriesSplit(n_splits=3)

random_search = RandomizedSearchCV(
    model,
    param_distributions=param_dist,
    n_iter=40,  # only 40 models (FAST)
    cv=tscv,
    scoring=smape_scorer,
    verbose=1,
    n_jobs=-1,
    random_state=42
)

random_search.fit(X_train, y_train)

best_model = random_search.best_estimator_

print("Best Parameters:", random_search.best_params_)

# =========================
# FINAL EVALUATION
# =========================

y_pred = best_model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100
smape_val = smape(y_test.values, y_pred)

print("\n===== Evaluation =====")
print("MAE   :", mae)
print("RMSE  :", rmse)
print("MAPE  :", mape, "%")
print("SMAPE :", smape_val, "%")

# =========================
# PLOT
# =========================

plt.figure(figsize=(10,5))
plt.plot(test["ds"], y_test, label="Actual")
plt.plot(test["ds"], y_pred, label="Predicted")
plt.legend()
plt.title("Fast Tuned XGBoost Forecast")
plt.xticks(rotation=45)
plt.show()

# ==========================================
# MONTHLY PREDICTION TABLE (TEST PERIOD)
# ==========================================

monthly_results = test[["ds"]].copy()
monthly_results["Actual"] = y_test.values
monthly_results["Predicted"] = y_pred
monthly_results["Error"] = monthly_results["Actual"] - monthly_results["Predicted"]

print("\n===== MONTHLY TEST PREDICTIONS =====")
print(monthly_results)

# ==========================================
# QUARTERLY AGGREGATION (TEST PERIOD)
# ==========================================

monthly_results["Quarter"] = monthly_results["ds"].dt.to_period("Q")

quarterly_results = monthly_results.groupby("Quarter").agg({
    "Actual": "sum",
    "Predicted": "sum"
}).reset_index()

quarterly_results["Error"] = quarterly_results["Actual"] - quarterly_results["Predicted"]

print("\n===== QUARTERLY TEST PREDICTIONS =====")
print(quarterly_results)

# ==========================================
# EVALUATION SUMMARY
# ==========================================

print("\n===== FINAL EVALUATION =====")
print("MAE   :", mae)
print("RMSE  :", rmse)
print("MAPE  :", mape, "%")
print("SMAPE :", smape_val, "%")

# ==========================================
# FUTURE 12-MONTH FORECAST (RECURSIVE â€“ FIXED)
# ==========================================

future_predictions = []

last_known = df.copy()

for i in range(12):

    row = last_known.iloc[-1:].copy()

    # FIXED: safe month increment
    next_date = pd.to_datetime(row["ds"].values[0]) + pd.DateOffset(months=1)

    new_row = row.copy()
    new_row["ds"] = next_date
    new_row["time_index"] = last_known["time_index"].max() + 1

    # Month cyclic features
    month = next_date.month
    new_row["month_sin"] = np.sin(2*np.pi*month/12)
    new_row["month_cos"] = np.cos(2*np.pi*month/12)

    # Lag features
    for lag in [1,2,3,6,12]:
        new_row[f"lag_{lag}"] = last_known["y"].iloc[-lag]

    # Rolling features
    new_row["roll_mean_3"] = last_known["y"].tail(3).mean()
    new_row["roll_mean_6"] = last_known["y"].tail(6).mean()
    new_row["roll_std_6"] = last_known["y"].tail(6).std()
    new_row["diff_1"] = last_known["y"].iloc[-1] - last_known["y"].iloc[-2]

    # Predict
    X_new = new_row[features]
    pred = best_model.predict(X_new)[0]

    new_row["y"] = pred
    future_predictions.append([next_date, pred])

    last_known = pd.concat([last_known, new_row], ignore_index=True)

future_forecast = pd.DataFrame(
    future_predictions, columns=["ds", "Forecast"]
)

print("\n===== FUTURE 12-MONTH FORECAST =====")
print(future_forecast)


# ==========================================
# QUARTERLY FUTURE FORECAST
# ==========================================

future_forecast["Quarter"] = future_forecast["ds"].dt.to_period("Q")

future_quarterly = future_forecast.groupby("Quarter")["Forecast"].sum().reset_index()

print("\n===== FUTURE QUARTERLY FORECAST =====")
print(future_quarterly)

# ==========================================
# TRAINING PREDICTION
# ==========================================

y_train_pred = best_model.predict(X_train)

# Training metrics
mae_train = mean_absolute_error(y_train, y_train_pred)
rmse_train = np.sqrt(mean_squared_error(y_train, y_train_pred))
mape_train = np.mean(np.abs((y_train - y_train_pred) / y_train)) * 100

def smape(y_true, y_pred):
    denom = (np.abs(y_true) + np.abs(y_pred))
    denom[denom == 0] = 1
    return 100 * np.mean(2 * np.abs(y_pred - y_true) / denom)

smape_train = smape(y_train.values, y_train_pred)

# ==========================================
# TEST PREDICTION
# ==========================================

y_test_pred = best_model.predict(X_test)

mae_test = mean_absolute_error(y_test, y_test_pred)
rmse_test = np.sqrt(mean_squared_error(y_test, y_test_pred))
mape_test = np.mean(np.abs((y_test - y_test_pred) / y_test)) * 100
smape_test = smape(y_test.values, y_test_pred)

# ==========================================
# PRINT COMPARISON
# ==========================================

print("===== TRAINING PERFORMANCE =====")
print("MAE   :", mae_train)
print("RMSE  :", rmse_train)
print("MAPE  :", mape_train, "%")
print("SMAPE :", smape_train, "%")

print("\n===== TEST PERFORMANCE =====")
print("MAE   :", mae_test)
print("RMSE  :", rmse_test)
print("MAPE  :", mape_test, "%")
print("SMAPE :", smape_test, "%")